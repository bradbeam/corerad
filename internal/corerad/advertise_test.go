// Copyright 2019 Matt Layher
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package corerad

import (
	"context"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"net"
	"sync"
	"sync/atomic"
	"testing"
	"time"

	"github.com/google/go-cmp/cmp"
	"github.com/mdlayher/corerad/internal/config"
	"github.com/mdlayher/ndp"
	"golang.org/x/net/ipv6"
	"golang.org/x/sync/errgroup"
)

func TestAdvertiserSimulated(t *testing.T) {
	// This tests simulates any interactions which may be difficult to test
	// with a veth pair.

	type msg struct {
		RA          *ndp.RouterAdvertisement
		Destination net.IP
	}

	tests := []struct {
		name     string
		readFrom func() (ndp.Message, *ipv6.ControlMessage, net.IP, error)
		check    func(t *testing.T, msgs []msg)
	}{
		{
			name: "unspecified source IP",
			readFrom: func() (ndp.Message, *ipv6.ControlMessage, net.IP, error) {
				// The Advertiser doesn't verify much at the moment so keep
				// most fields blank.
				return &ndp.RouterSolicitation{},
					&ipv6.ControlMessage{HopLimit: ndp.HopLimit},
					net.IPv6unspecified,
					nil
			},
			check: func(t *testing.T, msgs []msg) {
				// Only check the first message; we don't care about the
				// shutdown RA.
				if l := len(msgs); l != 2 {
					t.Fatalf("expected two messages, but got: %d", l)
				}

				// RAs verified elsewhere.

				// Unspecified source triggers multicast RA.
				if diff := cmp.Diff(net.IPv6linklocalallnodes, msgs[0].Destination); diff != "" {
					panicf("unexpected destination IP (-want +got):\n%s", diff)
				}
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
			defer cancel()

			var (
				mu   sync.Mutex
				msgs []msg
			)

			// Hook into the conn interface with our custom functions and consume
			// any router advertisements generated by the Advertiser.
			ad := NewAdvertiser(
				"test0",
				config.Interface{},
				log.New(ioutil.Discard, "", 0),
				NewAdvertiserMetrics(nil),
			)

			ad.dial = func(_ *net.Interface) (conn, net.IP, error) {
				c := newTestConn()
				c.readFrom = tt.readFrom
				c.writeTo = func(m ndp.Message, _ *ipv6.ControlMessage, dst net.IP) error {
					mu.Lock()
					defer mu.Unlock()

					msgs = append(msgs, msg{
						RA:          m.(*ndp.RouterAdvertisement),
						Destination: dst,
					})

					cancel()
					return nil
				}

				return c, nil, nil
			}

			ad.checkInterface = func(iface string) (*net.Interface, error) {
				return &net.Interface{
					Name:         iface,
					HardwareAddr: net.HardwareAddr{0xde, 0xad, 0xbe, 0xef, 0xde, 0xad},
				}, nil
			}

			// No need to check any system parameters.
			getNoop := func(_ string) (bool, error) { return true, nil }

			ad.getIPv6Autoconf = getNoop
			ad.getIPv6Forwarding = getNoop
			ad.setIPv6Autoconf = func(_ string, _ bool) error { return nil }

			var eg errgroup.Group
			eg.Go(func() error {
				if err := ad.Advertise(ctx); err != nil {
					return fmt.Errorf("failed to advertise: %v", err)
				}

				return nil
			})

			if err := eg.Wait(); err != nil {
				t.Fatalf("failed to wait: %v", err)
			}

			// Now that Advertiser has stopped, verify the results.
			mu.Lock()
			defer mu.Unlock()

			tt.check(t, msgs)
		})
	}
}

func Test_multicastDelay(t *testing.T) {
	// Static seed for deterministic output.
	r := rand.New(rand.NewSource(0))

	tests := []struct {
		name            string
		i               int
		min, max, delay time.Duration
	}{
		{
			name:  "static",
			min:   1 * time.Second,
			max:   1 * time.Second,
			delay: 1 * time.Second,
		},
		{
			name:  "random",
			min:   1 * time.Second,
			max:   10 * time.Second,
			delay: 4 * time.Second,
		},
		{
			name: "clamped",
			// Delay too long for low i value.
			i:     1,
			min:   30 * time.Second,
			max:   60 * time.Second,
			delay: maxInitialAdvInterval,
		},
		{
			name: "not clamped",
			// Delay appropriate for high i value.
			i:     100,
			min:   30 * time.Second,
			max:   60 * time.Second,
			delay: 52 * time.Second,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			d := multicastDelay(r, tt.i, tt.min.Nanoseconds(), tt.max.Nanoseconds())
			if diff := cmp.Diff(tt.delay, d); diff != "" {
				t.Fatalf("unexpected delay (-want +got):\n%s", diff)
			}
		})
	}
}

func newTestConn() *testConn {
	ctx, cancel := context.WithCancel(context.Background())

	return &testConn{
		reads: new(uint32),

		ctx:    ctx,
		cancel: cancel,
	}
}

type testConn struct {
	reads *uint32

	ctx    context.Context
	cancel func()

	close             func() error
	joinGroup         func(group net.IP) error
	leaveGroup        func(group net.IP) error
	readFrom          func() (ndp.Message, *ipv6.ControlMessage, net.IP, error)
	setControlMessage func(flags ipv6.ControlFlags, on bool) error
	setICMPFilter     func(f *ipv6.ICMPFilter) error
	writeTo           func(m ndp.Message, cm *ipv6.ControlMessage, dst net.IP) error
}

func (c *testConn) Close() error {
	if c.close == nil {
		return nil
	}

	return c.close()
}

func (c *testConn) JoinGroup(group net.IP) error {
	if c.joinGroup == nil {
		return nil
	}

	return c.joinGroup(group)
}

func (c *testConn) LeaveGroup(group net.IP) error {
	if c.leaveGroup == nil {
		return nil
	}

	return c.leaveGroup(group)
}

func (c *testConn) ReadFrom() (ndp.Message, *ipv6.ControlMessage, net.IP, error) {
	// Don't block first read.
	if atomic.AddUint32(c.reads, 1) == 1 {
		return c.readFrom()
	}

	// Subsequent reads will block, simulating a network connection wait.
	<-c.ctx.Done()
	return nil, nil, nil, c.ctx.Err()
}

func (c *testConn) SetControlMessage(flags ipv6.ControlFlags, on bool) error {
	if c.setControlMessage == nil {
		return nil
	}

	return c.setControlMessage(flags, on)
}

func (c *testConn) SetICMPFilter(f *ipv6.ICMPFilter) error {
	if c.setICMPFilter == nil {
		return nil
	}

	return c.setICMPFilter(f)
}

func (c *testConn) SetReadDeadline(t time.Time) error {
	// We don't use deadlines in any other capacity other than for network
	// blocking cancelation at the moment.
	if !t.Equal(deadlineNow) {
		panic("testConn.SetReadDeadline only accepts deadlineNow")
	}

	c.cancel()
	return nil
}

func (c *testConn) WriteTo(m ndp.Message, cm *ipv6.ControlMessage, dst net.IP) error {
	return c.writeTo(m, cm, dst)
}

func panicf(format string, a ...interface{}) {
	panic(fmt.Sprintf(format, a...))
}
